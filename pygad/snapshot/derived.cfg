[rules]
# Definition of derived blocks. The rules have to be interpretable by Snap.get
# (with the additional use of the aliases defined in the corresponding section).

# dist(a[,b]) is much faster than sqrt(sum((a[-b])**2, axis=1))
temp        = calc_temps(gas)               ; temperatures
r           = dist(pos)                     ; spherical radius
rcyl        = dist(pos[:,:2])               ; cylindrical radius
vrad        = UnitQty(inner1d(pos,vel),pos.units*vel.units)/r           ; radial velocities
momentum    = (mass * vel.T).T              ; momentum
angmom      = UnitQty(cross(pos,momentum),pos.units*momentum.units)     ; angular momentum
# the individual elements are automatically registered as derived arrays
metals      = elements.sum(axis=1) - (H+He) ; metal mass
Z           = metals/elements.sum(axis=1)   ; metallicity
alpha_el    = O+C+Ne+Si+Mg+S+Ca             ; alpha element mass
Ekin        = 0.5*mass*sum(vel**2,axis=1)   ; kinetic energy
# TODO: check if the zero point of the potential is what I expect
Epot        = mass*pot                      ; (Newtonian) potential energy
E           = Ekin+Epot                     ; (Newtonian) total energy
mag         = calc_mags(stars)              ; bolometric magnitudes
#mag         = UnitQty(inter_bc_qty(age,Z,'Mbol'), 'mag')         ; bolometric magnitudes
#mag_b       = UnitQty(inter_bc_qty(age,Z,'Bmag'), 'mag')         ; B-band magnitudes
#mag_v       = UnitQty(inter_bc_qty(age,Z,'Vmag'), 'mag')         ; V-band magnitudes
lum         = UnitQty(10**(-0.4*(mag-solar.abs_mag)),'Lsol')    ; bolometric luminosities
# the angular momentum a particle on a circular orbit with the same energy would have
jcirc       = r * sqrt(2.0*mass*Ekin)
# the parameter jz/jc, where jz is the z-component of the angular momentum and jc=jcirc:
jzjc        = angmom[:,2] / jcirc
vcirc       = sqrt(sum(vel**2,axis=-1) - vrad**2)   ; circular part of the velocities

